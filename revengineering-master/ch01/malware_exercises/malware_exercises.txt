/*
  Here there are functions samples about malware, it turns out while
  disassembling them, that the offset are different respect the book,
  are -4 bytes relative to what the book says, but that's not
  a problem, it is simple to identify a function looking at its
  prologue ;)

  For example sub_13846 is at sub_1382
*/

/*
  sub_13842 SAMPLE_H       
                                         
  mov     eax, [ecx+60h]
  push    esi
  mov     esi, [edx+8]
  dec     byte ptr [ecx+23h]
  sub     eax, 24h
  mov     [ecx+60h], eax
  mov     [eax+14h], edx
  movzx   eax, byte ptr [eax]
  push    ecx
  push    edx
  call    dword ptr [esi+eax*4+38h]
  pop     esi
  retn

*/


struct something1 {
  char a_char;         /* offset 23h */
  something3 s3;       /* offset 60h */
};

struct something2 {
  something s4;       /* offset 08h */
};

struct something3 {
  int index;         /* offset 00h */
  something2 *s2;    /* offset 14h */
};

struct something4 {
  void (*f)(struct something1 *, struct something2 *);    /* offset 38h */
  /*
    Here other function pointers... (maybe)
    Or an array of function pointers which contains also (*f)
   */
};
 
/* fastcall_convention */
sub_13842(struct something1 *ptr1, struct something2 *ptr2)
{
  struct something3 *s3 =  ptr1->offset_60h;
  struct something4 *s4 = ptr2->offset_08h;
  void (*function)(struct something1 *ptr1, struct something2 *ptr2);

  ptr1->offset_23h -= 0x1;
  ptr1->offset_60h -= 0x24;
  s3->offset_14h = ptr2;

  function = s4->offset_38h[(BYTE)s3->offset_00h];

  function(ptr1, ptr2);  
}

/* ------------------------------------------------------------------------ */

/*
  sub_10BB2 SAMPLE_H
  
  10bb2:	8b 44 24 04          	mov    eax,DWORD PTR [esp+0x4]  ; move to eax the begin of a PE
  10bb6:	53                   	push   ebx
  10bb7:	56                   	push   esi
  10bb8:	8b 70 3c             	mov    esi,DWORD PTR [eax+0x3c] ; put into ESI the value of the offset to PE signature
  10bbb:	03 f0                	add    esi,eax                  ; adjust ESI to be the address of the starting _IMAGE_NT_HEADERS
  10bbd:	0f b7 46 14          	movzx  eax,WORD PTR [esi+0x14]  ; copy into EAX the value of _IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader
  10bc1:	33 db                	xor    ebx,ebx                  ; zeroes EBX
  10bc3:	66 39 5e 06          	cmp    WORD PTR [esi+0x6],bx    ; check if _IMAGE_FILE_HEADER.FileHeader.NumberOfSections is zero
  10bc7:	57                   	push   edi
  10bc8:	8d 7c 30 18          	lea    edi,[eax+esi*1+0x18]     ; eax = SizeOfOptionalHeader, esi = _IMAGE_NT_HEADERS
                                                                        ; so esi + eax + 0x18 (0x4 bytes of Signature + 0x14 bytes of _IMAGE_FILE_HEADER) = _IMAGE_SECTION_HEADER
  10bcc:	76 1d                	jbe    0x10beb                  ; if no sections, jump to 0x10beb and return 0
  10bce:	ff 74 24 14          	push   DWORD PTR [esp+0x14]     ; get the instruction pointer value from the _IMAGE_DOS_HEADER and push it
  10bd2:	57                   	push   edi                      ; push the section header
  10bd3:	ff 15 a4 69 01 00    	call   DWORD PTR ds:0x169a4     ; arguments to this function are call to "PVOID something(_IMAGE_SECTION_HEADER *ptr, _IMAGE_DOS_HEADER.e_ip)"
  10bd9:	85 c0                	test   eax,eax
  10bdb:	59                   	pop    ecx
  10bdc:	59                   	pop    ecx
  10bdd:	74 14                	je     0x10bf3                  ; if result was zero jump to 0x10bed and return the section (maybe modified ?)
  10bdf:	0f b7 46 06          	movzx  eax,WORD PTR [esi+0x6]   ; ...else put the number of sections into eax
  10be3:	83 c7 28             	add    edi,0x28                 ; edi = current section + sizeof(_IMAGE_SECTION_HEADER) = next section header
  10be6:	43                   	inc    ebx                      ; increment ebx
  10be7:	3b d8                	cmp    ebx,eax                  ; compare ebx with eax (iterate over sections)
  10be9:	72 e3                	jb     0x10bce
  10beb:	33 c0                	xor    eax,eax
  10bed:	5f                   	pop    edi                      ; restore registers
  10bee:	5e                   	pop    esi
  10bef:	5b                   	pop    ebx
  10bf0:	c2 08 00             	ret    0x8
  10bf3:	8b c7                	mov    eax,edi                   ; put the address of section header into eax
  10bf5:	eb f6                	jmp    0x10bed                   ; jump
*/

/*
  Taken from the MS PE specs:
  
  "The MS-DOS stub is a valid application that runs under MS-DOS. It is placed at the
  front of the EXE image. The linker places a default stub here, which prints out the
  message “This program cannot be run in DOS mode” when the image is run in
  MS-DOS. The user can specify a different stub by using the /STUB linker option.
  At location 0x3c, the stub has the file offset to the PE signature. This information
  enables Windows to properly execute the image file, even though it has an
  MS-DOS stub. This file offset is placed at location 0x3c during linking.

  After the MS-DOS stub, at the file offset specified at offset 0x3c, is a 4-byte
  signature that identifies the file as a PE format image file. This signature is “PE\0\0”
  (the letters “P” and “E” followed by two null bytes)."
*/

/*
  _IMAGE_DOS_HEADER:

  kd> dt nt!_IMAGE_DOS_HEADER
   +0x000 e_magic          : Uint2B
   +0x002 e_cblp           : Uint2B
   +0x004 e_cp             : Uint2B
   +0x006 e_crlc           : Uint2B
   +0x008 e_cparhdr        : Uint2B
   +0x00a e_minalloc       : Uint2B
   +0x00c e_maxalloc       : Uint2B
   +0x00e e_ss             : Uint2B
   +0x010 e_sp             : Uint2B
   +0x012 e_csum           : Uint2B
   +0x014 e_ip             : Uint2B
   +0x016 e_cs             : Uint2B
   +0x018 e_lfarlc         : Uint2B
   +0x01a e_ovno           : Uint2B
   +0x01c e_res            : [4] Uint2B
   +0x024 e_oemid          : Uint2B
   +0x026 e_oeminfo        : Uint2B
   +0x028 e_res2           : [10] Uint2B
   +0x03c e_lfanew         : Int4B                       ; here there's our offset to PE header

   kd> dt nt!_IMAGE_NT_HEADERS
   +0x000 Signature        : Uint4B                      
   +0x004 FileHeader       : _IMAGE_FILE_HEADER
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER

   kd> dt nt!_IMAGE_FILE_HEADER
   +0x000 Machine          : Uint2B
   +0x002 NumberOfSections : Uint2B
   +0x004 TimeDateStamp    : Uint4B
   +0x008 PointerToSymbolTable : Uint4B
   +0x00c NumberOfSymbols  : Uint4B
   +0x010 SizeOfOptionalHeader : Uint2B
   +0x012 Characteristics  : Uint2B

   kd> dt nt!_IMAGE_OPTIONAL_HEADER
   +0x000 Magic            : Uint2B
   +0x002 MajorLinkerVersion : UChar
   +0x003 MinorLinkerVersion : UChar
   +0x004 SizeOfCode       : Uint4B
   +0x008 SizeOfInitializedData : Uint4B
   +0x00c SizeOfUninitializedData : Uint4B
   +0x010 AddressOfEntryPoint : Uint4B
   +0x014 BaseOfCode       : Uint4B
   +0x018 BaseOfData       : Uint4B
   +0x01c ImageBase        : Uint4B
   +0x020 SectionAlignment : Uint4B
   +0x024 FileAlignment    : Uint4B
   +0x028 MajorOperatingSystemVersion : Uint2B
   +0x02a MinorOperatingSystemVersion : Uint2B
   +0x02c MajorImageVersion : Uint2B
   +0x02e MinorImageVersion : Uint2B
   +0x030 MajorSubsystemVersion : Uint2B
   +0x032 MinorSubsystemVersion : Uint2B
   +0x034 Win32VersionValue : Uint4B
   +0x038 SizeOfImage      : Uint4B
   +0x03c SizeOfHeaders    : Uint4B
   +0x040 CheckSum         : Uint4B
   +0x044 Subsystem        : Uint2B
   +0x046 DllCharacteristics : Uint2B
   +0x048 SizeOfStackReserve : Uint4B
   +0x04c SizeOfStackCommit : Uint4B
   +0x050 SizeOfHeapReserve : Uint4B
   +0x054 SizeOfHeapCommit : Uint4B
   +0x058 LoaderFlags      : Uint4B
   +0x05c NumberOfRvaAndSizes : Uint4B
   +0x060 DataDirectory    : [16] _IMAGE_DATA_DIRECTORY

   kd> dt nt!_IMAGE_SECTION_HEADER
   +0x000 Name             : [8] UChar
   +0x008 Misc             : __unnamed
   +0x00c VirtualAddress   : Uint4B
   +0x010 SizeOfRawData    : Uint4B
   +0x014 PointerToRawData : Uint4B
   +0x018 PointerToRelocations : Uint4B
   +0x01c PointerToLinenumbers : Uint4B
   +0x020 NumberOfRelocations : Uint2B
   +0x022 NumberOfLinenumbers : Uint2B
   +0x024 Characteristics  : Uint4B
*/

/*
  NOTE: I really don't know Windows API!
  So this are just supposition based on the fact
  that I'm studying its APIs while I find them in
  the book/exercises.
  And also this pseudocode sucks... :/
*/

/*
  ptr: a pointer to a memory mapped file

  This function iterates over the _IMAGE_SECTION_HEADERS of a PE file
  it then pass the current section header to another function
  followed to the Instruction Pointer taken from the _IMAGE_DOS_HEADER
*/
PVOID sub_10BB2(PVOID ptr)
{
  PVOID ptr1 = ptr;
  PVOID ptr2 = ptr1 + (int *)(ptr1 + 0x3c); /* offset where the PE _IMAGE_NT_HEADERS starts */
  PVOID ptr3;
  PVOID ret;

  *ptr1 = (int *)(ptr2 + 0x14); /* _IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader */

  if(*ptr1 == 0)
    return 0;

  ptr3 = *ptr1 + ptr2 + 0x18; /* Point to the first _IMAGE_SECTION_HEADER */

  while(*ptr1){
    ret = call_some_stuff(ptr3, (int *)(ptr + 0x14)); /* First argument is an _IMAGE_SECTION_HEADER, second arg
						   is _IMAGE_DOS_HEADER.e_ip (instruction pointer)" */
    if(ret == NULL)
      return 0;

    (*ptr1)--;

    ptr3 += 0x28; /* Advance pointer to next _IMAGE_SECTION_HEADER, each section is 0x28 bytes */
  }

  return ret;
				   
}
  
